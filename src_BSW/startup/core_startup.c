/**
 * Project:	Student Car v3
 *
 * \file	core_startup.c
 *
 * \author	Piotr Moron
 * 			Dilip Mavuram
 * 			Thomas Barth 	Hochschule Darmstadt - thomas.barth@h-da.de
 *
 * \version	0.1 	03.05.2016
 *
 *  @brief Startup code and basic configuration for the AURIX
 *
 *  This file is the entry point after startup. It hosts the BMHD for the basic HW configuration and is setting up the CPUs.
 *  During startup, the CPUs will be configured according to #CPUInit which is using linker-symbols. After the basic configuration,
 *  The CPUs will perform clear and copy operations, based on the clear and copy tables generated by the linker.
 *
 *	Changelog:
 *
 */

//***********************************************************************************//
//**************** Header ***********************************************************//
//***********************************************************************************//
#include <string.h>	//memset, memcpy
#include "core.h"

//***********************************************************************************//
//**************** Local declarations ***********************************************//
//***********************************************************************************//
/**
 * @brief Bootloader
 *
 * This function is the entry point after start (linked to start-address).
 * It will call get the pointer to the CPU-configurationa and call the startup-code in #csrart
 */
void _start(void);

/**
 * @brief Startup Code
 *
 * Configures the CPU and calls "main".
 * During startup the Watchdogs, Trap-and Interrupt-Tables, Call-Depth-Counter, SDA and CSA are configured.
 * The startup code also is initializing RAM with clear and copy tables.
 * @param	corePtr	Pointer to the CPU-Configuration for the current core.
 */
void cstart(const CoreInit_t *corePtr) 					__attribute__ ((interrupt,noinline));

/**
 * @brief ENDINIT Clear
 *
 * Safety crititcal registers on the TriCore CPUs are ENDINIT protected. This protection can be temporarily unlocked with
 * the CPU-Watchdog Timers. This function unlocks the ENDINIT protection for the current core. The protection needs to be
 * locked with #WDT_SetEndinit after the register-write operations are performed.
 * @param	wdtbase	Pointer to the WDT of the current core
 */
static 	void WDT_ClearEndinit(volatile uint32_t *wdtbase) 		__attribute__ ((interrupt,noinline));

/**
 * @brief ENDINIT Clear
 *
 * Safety crititcal registers on the TriCore CPUs are ENDINIT protected. This protection can be temporarily unlocked with
 * the CPU-Watchdog Timers. This function locks the ENDINIT protection for the current core after it had been unlocked with #WDT_ClearEndinit
 * @param	wdtbase	Pointer to the WDT of the current core
 */
static 	void WDT_SetEndinit(volatile uint32_t *wdtbase) 		__attribute__ ((interrupt,noinline));

/**
 * @brief Clears (set 0) defined memory-areas
 *
 * After start or reboot, certain memory-areas in RAM need to cleared to ensure the application is not processing "garbage".
 * This function iterates trough a list of memory areas (usually provided by the linker) and resets the bits in those areas.
 * @param	table	Pointer to clear-table
 */
static 	void clear_table_func(const ClearTable_t *table) 		__attribute__ ((interrupt));

/**
 * @brief copies defined memory-areas
 *
 * After start or reboot, certain memory-areas in RAM need to copied to ensure that initialized variables are available.
 * Usually the linker provides information about which ROM areas need to be copied to RAM. This function is iterating
 * trough a given list and is performing the copy operations.
 * @param	table	Pointer to copy-table
 */
static 	void copy_table_func(const CopyTable_t *table) 			__attribute__ ((interrupt));

/**
 * @brief Initializes the CSA
 */
static 	void init_csa(uint32_t csa_base, uint32_t csa_size) 	__attribute__ ((interrupt));

//***********************************************************************************//
//**************** Linker Script references *****************************************//
//***********************************************************************************//
/**
 * @brief The attribute fardata overrides small- or absolute addressing access set by -msmall and -mabs.
 *
 * Variables marked with this attribute will not be moved to small or absolute sections, even if their size specifies to do so.
 * (HighTech User Guide v4.6.5.0)
 */
#define _FARDATA  __attribute__((fardata))

/**
 * @brief A function with the "weak" attribute has its name emitted as a weak symbol instead of a global name.
 *
 * This is primarily for the naming of library routines that can be overridden by user code.
 * Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.
 * (HighTech User Guide v4.6.5.0)
 */
#define _WEAK  		__attribute__((weak))

EXTERN _FARDATA const ClearTable_t 	__clear_table_CPU0_;				/**< @brief Clear Table for CPU0*/
EXTERN _FARDATA const ClearTable_t 	__clear_table_CPU1_;				/**< @brief Clear Table for CPU1*/
EXTERN _FARDATA const ClearTable_t 	__clear_table_CPU2_;				/**< @brief Clear Table for CPU2*/

EXTERN _FARDATA const CopyTable_t  	__copy_table_CPU0_;					/**< @brief Copy Table for CPU0*/
EXTERN _FARDATA const CopyTable_t  	__copy_table_CPU1_;					/**< @brief Copy Table for CPU1*/
EXTERN _FARDATA const CopyTable_t  	__copy_table_CPU2_;					/**< @brief Copy Table for CPU2*/

EXTERN _FARDATA uint32_t            PXROS_SYSTEM_STACK;					/**< @brief XROS Stack that will be placed in the corresponding DSPRs*/

EXTERN _FARDATA uint32_t            PXROS_SYSTEM_STACK_CPU0_;					/**< @brief XROS Stack that will be placed in the corresponding DSPRs*/
EXTERN _FARDATA uint32_t            PXROS_SYSTEM_STACK_CPU1_;					/**< @brief XROS Stack that will be placed in the corresponding DSPRs*/
EXTERN _FARDATA uint32_t            PXROS_SYSTEM_STACK_CPU2_;					/**< @brief XROS Stack that will be placed in the corresponding DSPRs*/


EXTERN _FARDATA	uint32_t			__INIT_INT_TAB_BEGIN;				/**< @brief The Initial interrupt Table, note that entries are addressed with their Priority, there are no fixed vectores.*/

EXTERN _FARDATA uint32_t			__INIT_TRAPTAB_BEGIN;				/**< @brief the Trap-Table for bare-metal operation*/

EXTERN _FARDATA uint32_t      		_SMALL_DATA_ 			_WEAK;		/**< @brief Small addressable Data area with base A0 */
EXTERN _FARDATA uint32_t      		_SMALL_DATA2_ 			_WEAK;		/**< @brief Small addressable Data area with base A1 */
EXTERN _FARDATA uint32_t      		_SMALL_DATA3_ 			_WEAK;		/**< @brief Small addressable Data area with base A8 */
EXTERN _FARDATA uint32_t      		_SMALL_DATA4_CPU0_ 		_WEAK;		/**< @brief Small addressable Data area with base A9 for Core 0 */
EXTERN _FARDATA uint32_t      		_SMALL_DATA4_CPU1_ 		_WEAK;		/**< @brief Small addressable Data area with base A9 for Core 1 */
EXTERN _FARDATA uint32_t      		_SMALL_DATA4_CPU2_ 		_WEAK;		/**< @brief Small addressable Data area with base A9 for Core 2 */

/* The CPU uses a uniform context-switching method for function calls, interrupts and traps.
 * In all cases the Upper Context of the task is automatically saved and restored by hardware. (TC27x Manual)
 * The memory for this operation is called Content Switch Area (CSA) */
EXTERN _FARDATA uint32_t      		__CSA_BEGIN[];			// begin of CSA (usually local DSPR)
EXTERN _FARDATA uint32_t      		__CSA_SIZE[];			// size of CSA


/* CPU configuration Table */
_FARDATA const CoreInit_t CPUInit[3] = {

		/* Core 0 */
		{
				&__clear_table_CPU0_,	// reference to the clear table. All memory-areas in this list will be cleared
				&__copy_table_CPU0_,	// reference to the copy table.
				&PXROS_SYSTEM_STACK_CPU0_,	// Interrupt Stack
				&PXROS_SYSTEM_STACK_CPU0_,	// Initial User-Stack
				&_SMALL_DATA_,			// base of the small data area with base A0
				&_SMALL_DATA2_,			// base of the small data area with base A1
				&_SMALL_DATA3_,			// base of the small data area with base A8
				&_SMALL_DATA4_CPU0_,	// base of the small data area with base A9
				(uint32_t)__CSA_BEGIN,	// CSA base
				(uint32_t)__CSA_SIZE,	// CSA size
				&__INIT_INT_TAB_BEGIN,	// Initial Interrupt-Table
				&__INIT_TRAPTAB_BEGIN,	// The CPU is initialized with the init Trap-Table
				&SCU_WDTCPU0CON0,		// CPU Watchdog register 0
				&SCU_WDTCPU0CON1		// CPU Watchdog register 1
		},

		/* Core 1 */
		{
				&__clear_table_CPU1_,	// reference to the clear table. All memory-areas in this list will be cleared
				&__copy_table_CPU1_,	// reference to the copy table.
				&PXROS_SYSTEM_STACK_CPU1_,	// Interrupt Stack
				&PXROS_SYSTEM_STACK_CPU1_,	// Initial User-Stack
				&_SMALL_DATA_,			// base of the small data area with base A0
				&_SMALL_DATA2_,			// base of the small data area with base A1
				&_SMALL_DATA3_,			// base of the small data area with base A8
				&_SMALL_DATA4_CPU1_,	// base of the small data area with base A9
				(uint32_t)__CSA_BEGIN,	// CSA base
				(uint32_t)__CSA_SIZE,	// CSA size
				&__INIT_INT_TAB_BEGIN,	// Initial Interrupt-Table
				&__INIT_TRAPTAB_BEGIN,	// The CPU is initialized with the init Trap-Table
				&SCU_WDTCPU1CON0,		// CPU Watchdog register 0
				&SCU_WDTCPU1CON1		// CPU Watchdog register 1
		},

		/* Core 2 */
		{
				&__clear_table_CPU2_,	// reference to the clear table. All memory-areas in this list will be cleared
				&__copy_table_CPU2_,	// reference to the copy table.
				&PXROS_SYSTEM_STACK_CPU2_,	// Interrupt Stack
				&PXROS_SYSTEM_STACK_CPU2_,	// Initial User-Stack
				&_SMALL_DATA_,			// base of the small data area with base A0
				&_SMALL_DATA2_,			// base of the small data area with base A1
				&_SMALL_DATA3_,			// base of the small data area with base A8
				&_SMALL_DATA4_CPU2_,	// base of the small data area with base A9
				(uint32_t)__CSA_BEGIN,	// CSA base
				(uint32_t)__CSA_SIZE,	// CSA size
				&__INIT_INT_TAB_BEGIN,	// Initial Interrupt-Table
				&__INIT_TRAPTAB_BEGIN,	// The CPU is initialized with the init Trap-Table
				&SCU_WDTCPU2CON0,		// CPU Watchdog register 0
				&SCU_WDTCPU2CON1		// CPU Watchdog register 1
		}
};

#pragma section ".startup.bmhd" a
/**
 * @brief Boot-Mode-Header (BMHD)
 *
 * The BMHD is a block of data that needs to be linked to the start of Flash0.
 * It is configuring the System on the lowest level, e.g. it will define where the bootloader is located,
 * if the lockstep cores are available and which boot mode shall be used (or if it is possible to select the boot-mode externaly)
 * The BMHD needs a hard-reset (power on/off) to become active after flashing.
 */
const uint32_t BootModeHeader_0[] =
{
   0x80000020,      // User Code Start Address
   0xb3590370,      // Boot Mode Header ID B359H, Boot Mode Index (BMI) Lockstep on C0&1 active
   0x00000000,      // Memory Range to be checked - Start Address
   0x00000000,      // Memory Range to be checked - End Address
   0x00000000,      // Check Result for the Memory Range
   0x00000000,      // Inverted Check Result for the Memory Range
   0x49E9B5B4,      // Check Result for the ABM Header (offset 00H..17H)
   0xB6164A4B       // Inverted Check Result for the ABM Header
};
#pragma section

#pragma section ".startup.text" ax
void _start(void){

	const 	CoreInit_t	*p_Core;	// pointer to the configuration for this Core
			uint32_t    coreID;     // Storage for the current Core-ID

	// get the core ID from CPU_ID
	coreID = __MFCR(CPU_CORE_ID);

	//get the configuration
	p_Core = &CPUInit[coreID];

	// Initialize stack Pointer
	__asm__ ("mov.aa %%sp, %0" :: "a" (p_Core->ustack): "a10");

	//execute startup-code
	cstart(p_Core);
}
#pragma section

#pragma section ".text.startupcode" ax
/* the initial startup routine. Tasks:
 *		- initialize the global RAM
 * 		- start the other CPUs
 * 		- disable/enable System Watchdog
 * 		- call the main function
 */
void cstart(const CoreInit_t *corePtr){

	//storage for the Process status word (PSW)
	uint32_t psw;

	// reset endinit and disable watchdog
	if (corePtr->wdtCon0->U & 1)
		/* clear endinit bit on CPU WDT */
		WDT_ClearEndinit( (uint32_t*) &corePtr->wdtCon0->U);

	//Core 0 clears SENDINIT on SWDT
	if ((corePtr == &CPUInit[0]) && (*&SCU_WDTSCON0.U & 1))
		/* clear endinit bit on Safety WDT */
		WDT_ClearEndinit( (uint32_t*) &SCU_WDTSCON0.U);

	// setup interrupt stack - CPU Endinit protected
	_mtcr(CPU_ISP, (uint32_t)corePtr->istack);

	// install trap handlers - CPU Endinit protected
	_mtcr(CPU_BTV, (uint32_t)corePtr->TrapTable);
	_isync();	//flush pipeline

	// install interrupt handlers
	_mtcr(CPU_BIV, (uint32_t)corePtr->InterruptTable);
	_isync();	//flush pipeline

	// initialize call depth counter (CDC)
	psw  = _mfcr(CPU_PSW);									// get current PSW
	psw |= IFX_CPU_PSW_CDC_MSK;								// set CDC mask in PSW
	psw &= ~(IFX_CPU_PSW_CDE_MSK << IFX_CPU_PSW_CDE_OFF);
	_mtcr(CPU_PSW, psw);									// set new PSW
	_isync();												//flush pipeline

	// enable write access to system global registers
	psw  = _mfcr(CPU_PSW);									// get current PSW
	psw |= (IFX_CPU_PSW_GW_MSK << IFX_CPU_PSW_GW_OFF);		// set bits for global register access
	_mtcr(CPU_PSW, psw);									// set new PSW
	_isync();												//flush pipeline

	// initialise SDA base pointers
	__asm volatile ("mov.aa %%a0, %0" : : "a" (corePtr->smallA0));
	__asm volatile ("mov.aa %%a1, %0" : : "a" (corePtr->smallA1));
	__asm volatile ("mov.aa %%a8, %0" : : "a" (corePtr->smallA8));
	__asm volatile ("mov.aa %%a9, %0" : : "a" (corePtr->smallA9));

	// disable write access to system global registers
	psw  = _mfcr(CPU_PSW);									// get current PSW
	psw &= ~(IFX_CPU_PSW_GW_MSK << IFX_CPU_PSW_GW_OFF);		// set bits to lock global register access
	_mtcr(CPU_PSW, psw);									// set new PSW
	_isync();												//flush pipeline

	// Core 0 disables safety watchdog
	if (corePtr == &CPUInit[0])
	{
		SCU_WDTSCON1.B.DR = 1;
		WDT_SetEndinit( (uint32_t*) &SCU_WDTSCON0.U);
	}

	// Set ENDINIT
	corePtr->wdtCon1->B.DR = 1;
	WDT_SetEndinit( (uint32_t*) &corePtr->wdtCon0->U);

	// init CSA (Context switch area)
	init_csa(corePtr->csaBase,corePtr->csaSize);

	// clear and copy operations
	clear_table_func(corePtr->cleartable);
	copy_table_func(corePtr->copytable);

	//Call ctor init
	if (corePtr == &CPUInit[0])
	{
		//To initialise the constructors
		_init();
	}

	// entry to the main function. Absolute jump because the CDC is active
	__absolute_jump(main);
}

static void WDT_ClearEndinit (volatile uint32_t *wdtbase){

	//storage for WD password
	uint32_t passwd;

	// password extraction and modification
	passwd = *wdtbase;
	passwd &= 0xffffff00;
	*wdtbase = passwd | 0xf1;
	*wdtbase = passwd | 0xf2;

	// read back new value ==> synchronise LFI
	(void) *wdtbase;
}

static void WDT_SetEndinit (volatile uint32_t *wdtbase){

	//storage for WD password
	uint32_t passwd;

	passwd = *wdtbase;
	passwd &= 0xffffff00;
	*wdtbase = passwd | 0xf1;
	*wdtbase = passwd | 0xf3;

	// read back new value ==> synchronise LFI
	(void) *wdtbase;
}

static void clear_table_func(const ClearTable_t *p_pointer){

	//iterate trough clear table until EOR (-1) is reached
	while (p_pointer->size >= 0)
	{
		//set 0s for given memory area
		memset(p_pointer->base,0l,p_pointer->size);

		//go to next entry
		p_pointer++;
	}
}

static void copy_table_func(const CopyTable_t *p_pointer){

	//iterate trough clear table until EOR (-1) is reached
	while (p_pointer->size >= 0)
	{
		//copy data from source to destination
		memcpy(p_pointer->dst,p_pointer->src,p_pointer->size);

		//go to next entry
		p_pointer++;
	}
}

static void init_csa(uint32_t csa_base, uint32_t csa_size){

	csa_t       *pcsa;							// pointer to the CSA
	pcxi_t      pcxi;							// PCXI - Previous Context Information
	uint32_t 	current_csa;					// address of the current CSA

	// initialize PCXI by resetting it
	__MTCR(CPU_PCXI,0);

	csa_base = (csa_base + 0x3f) & ~0x3f;       // force 2^6 alignment
	csa_size = csa_size/0x40;                   // number of csa entries

	pcsa = (csa_t *)csa_base;					//get pointer to CSA

	pcsa->reg[0] = 0;
	pcsa++;
	current_csa = csa_base;

	pcxi.bits.pcxs = csa_base >> 28;                				// segment of csa area
	pcxi.bits.pcxo = ((csa_base+(3*sizeof(csa_t))) >> 6 ) & 0xffff; // get csa index

	// 2 more CSA for traphandling in depletion trap
	__MTCR(CPU_LCX, pcxi.reg);      // initialize LCX - Free Context List Limit Pointer

	csa_size -= 2; 					// CSA's to initialize -=2

	while (csa_size--)
	{
		pcxi.bits.pcxo = (current_csa >> 6) & 0xffff;
		pcsa->reg[0] = pcxi.reg;
		pcsa++;
		current_csa += sizeof(csa_t);
	}
	pcxi.bits.pcxo = (current_csa >> 6) & 0xffff;
	__MTCR(CPU_FCX,pcxi.reg);                    // initialize FCX
}
#pragma section

/*******************************************************************************************************************************************
*******************************************************************************************************************************************/

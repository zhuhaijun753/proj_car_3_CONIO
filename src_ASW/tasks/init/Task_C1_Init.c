/*************************************
 * Task_C1_Init.h
 * Author: 			Fromm
 * Description: 	Initialisation Task of Core 1
 * Task creation: 	
 * This file is auto-generated by PxROS Generator (c) Hochschule Darmstadt, Linde
 */

/*******************************************************************************************************
 * Includes
 *******************************************************************************************************/

// System
#include "core.h"
#include "pxdef.h"


//Debugging aid
#include "det.h"
#include "sync.h"
#include "rte_time.h"

//System Tasks
#include "Task_ReleaseServer.h"
#include "Task_Time.h"
#include "Task_Services.h"

//Global adress symbols
#include "symbols.h"
#include "SystemEvents.h"

//Own header
#include "Task_Init.h"
#include "Task_C1_Init.h"

//Application Tasks

#include "Task_C1_Control.h"

//Trap Handler
#include "trap_handler_runtime.h"




/*******************************************************************************************************
 * Pragma sections
 *******************************************************************************************************/

 //To allow some core specific handling later one...
 #define CORE 1

//Task local memory (stack)
#pragma section ".Task_C1_Init.stack"
struct
{
	PxStackAligned_t stack[TASK_C1_INIT_STACKSIZE_CORE1];
	PxStackAligned_t intstack[TASK_C1_INIT_INTSTACKSIZE_CORE1];
	PxChar_t	     stack_protectionPad[6] __attribute__ ((aligned(8)));
} Task_C1_Init_obj;
#pragma section

#pragma section ".Task_Init_Lock.data" awB 8
//Data to be added
#pragma section

/*******************************************************************************************************
 * Protection regions Task_C1_Init
 *******************************************************************************************************/

//Task data access (variable)
static const PxProtectRegion_T InitTaskRegions_CORE1[] = {
		

	//Complete peripheral memory
	{ (PxUInt_t) PERIPHERAL_START, (PxUInt_t) PERIPHERAL_END, (PxProtectType_t)WRProtection},


	//Global task memory
	{ (PxUInt_t) __GLOBAL_TASK_BEGIN, (PxUInt_t) __GLOBAL_TASK_END, (PxProtectType_t)WRProtection},

	//Stores data which is created by the Inittask, e.g. task and message Id's
	{ (PxUInt_t) __GLOBAL_RW_INIT_RO_AFTERWARDS_BEGIN, (PxUInt_t) __GLOBAL_RW_INIT_RO_AFTERWARDS_END, (PxProtectType_t)WRProtection},
		{0,0,0}
};

//Task data access (fixed) - do not change
static const PxTaskContext_T InitTaskContext_CORE1 = {
	.protection[0] =
	{
	    .lowerBound = (PxUInt_t)&PxTricSystemRodataLowerBound,
        .upperBound = (PxUInt_t)&PxTricSystemRodataUpperBound,
        .prot 		= ReadProtection
	}
	,
	.protection[1] =
	{
	    .lowerBound = (PxUInt_t)&Task_C1_Init_obj.stack,
        .upperBound = (PxUInt_t)&Task_C1_Init_obj.stack_protectionPad[0],
        .prot 		= WRProtection
	}

};

/*******************************************************************************************************
 * Init specification Task_C1_Init
 *******************************************************************************************************/

const PxTaskSpec_T InitTaskSpec_CORE1 =
{
		.ts_name = (const PxChar_t *)"Task_C1_Init",
		.ts_fun = Task_C1_Init_Func,
		.ts_mc = PXMcTaskdefault,
		.ts_opool = PXOpoolSystemdefault,
		.ts_privileges = PXUser1Privilege,
		.ts_accessrights = 0| PXACCESS_HANDLERS| PXACCESS_INSTALL_HANDLERS| PXACCESS_INSTALL_SERVICES| PXACCESS_REGISTERS| PXACCESS_SYSTEMDEFAULT| PXACCESS_RESOURCES| PXACCESS_NEW_RESOURCES| PXACCESS_SYSTEM_CONTROL| PXACCESS_MODEBITS| PXACCESS_OVERRIDE_ABORT_EVENTS | PXACCESS_TASK_CREATE | PXACCESS_TASK_CREATE_HIGHER_PRIO | PXACCESS_TASK_SET_HIGHER_PRIO | PXACCESS_CHANGE_PRIO | PXACCESS_TASK_RESTORE_ACCESS_RIGHTS | PXACCESS_TASK_CREATE_HIGHER_ACCESS ,
		.ts_context = &InitTaskContext_CORE1,
		.ts_protect_region = InitTaskRegions_CORE1,
		.ts_taskstack =
		{
			.stk_type = PXStackFall,
			.stk_size = PXStackDontCheck,
			.stk_src.stk = &Task_C1_Init_obj.stack[TASK_C1_INIT_STACKSIZE_CORE1]
		},
		.ts_inttaskstack =
		{
			.stk_type = PXStackFall,
			.stk_size = PXStackDontCheck,
			.stk_src.stk = &Task_C1_Init_obj.intstack[TASK_C1_INIT_INTSTACKSIZE_CORE1]
		},
		.ts_abortstacksize = 0

};


/*******************************************************************************************************
 * Task function Task_C1_Init
 *******************************************************************************************************/


void Task_C1_Init_Func(PxTask_t myID, PxMbx_t myMailbox, PxEvents_t myActivationEvents)
{

	// Turn off warning
	(void) myID;
	(void) myMailbox;
	(void) myActivationEvents;

	//Local Variable to check return status of PxRos functions
	PxError_t result;



/*******************************************************************************************************
 * Initialise System Services
 *******************************************************************************************************/

    //Set up Trap Handlers
    PxTrapInstallHandler(0x0,Px_trap_hdl_0,0);
    PxTrapInstallHandler(0x1,Px_trap_hdl_1,0);
    PxTrapInstallHandler(0x2,Px_trap_hdl_2,0);
    PxTrapInstallHandler(0x3,Px_trap_hdl_3,0);
    PxTrapInstallHandler(0x4,Px_trap_hdl_4,0);
    PxTrapInstallHandler(0x5,Px_trap_hdl_5,0);
    PxTrapInstallHandler(0x6,Px_trap_hdl_6,0);
    PxTrapInstallHandler(0x7,Px_trap_hdl_7,0);

	// Start PXROS time base with HZ (defined in clock.h) ticks per second.
	//Needs to be done on every core
	SYSTICK_TicksInit(1000);

	PxUInt_t id = PxGetCoreId();

#if CORE == 0
	// Initialize the name server only on core 0
	PxTask_t NameSrv;
	NameSrv = PxNamesrvInit(NAMESRV_PRIO_CORE0, PxNameServerSpaceBase, (PxUInt_t)PxNameServerSpaceEnd-(PxUInt_t)PxNameServerSpaceBase);
	if ( (result = PxTaskIdError(NameSrv)) != PXERR_NOERROR)
	{
		DET_stop(1,CREATENAMESERVER, result);
	}
#endif
	// Initialise the release server
	// Task_ReleaseService_Id must run for PxGetGlobalNameServerMbx
	PxTask_t Task_ReleaseServer_Id;
	Task_ReleaseServer_Id = Task_ReleaseServerCreate(id,TASK_RELEASESERVER_PRIO, TASK_RELEASESERVER_ACTIVATION_EVENTS);
	if ((result = PxTaskIdError(Task_ReleaseServer_Id)) != PXERR_NOERROR)
	{
		DET_stop(1,CREATERELEASESERVER, result);
	}

	//Set the local priority to the highest value, so that no application task can start, before all of them are created
	PxTaskSetPrio(PxGetId(), 15);

	//PXROS Service Tasks on core 0 finished
	SYNC_SetC1(BASE_SYSTEM_INIT);

/*******************************************************************************************************
 * Check if the nameserver is already up and running
 *******************************************************************************************************/


    //Check if the a mailbox can be requested from the name server
    result = WaitForService (PXCORE_0, _PxNameSrvReqMbxId, 10);

    if ( result != PXERR_NOERROR)
    {
    	DET_stop(AUTOCORE,CHECKSERVICE, result);
    }

/*******************************************************************************************************
 * Create application tasks here (Tasks and Mailboxes) and register them with the nameserver
 *******************************************************************************************************/	
	
		
/****************  Task_C1_Control ********************/

    //Create a local info block which will be stored on the nameserver
    taskinfo_t Task_C1_Control_info;

    //Call the task create function
    PxTask_t Task_C1_Control_Id;
    Task_C1_Control_Id = Task_C1_Control_Create(TASK_C1_CONTROL_PRIO, ev_Task_C1_Control_0_Activate);

    result = PxTaskIdError(Task_C1_Control_Id);
    if (result != PXERR_NOERROR)
    {
	    DET_stop(AUTOCORE,CREATETASK, result);
    }

    // Get the handler to the tasks message box
    PxMbx_t Task_C1_Control_Mbx = PxTaskGetMbx(Task_C1_Control_Id);

    // Register information about Task and Mbx Id ==> the structure of the data depends on the application requirements
    Task_C1_Control_info.taskId = Task_C1_Control_Id;
    Task_C1_Control_info.mbxId = Task_C1_Control_Mbx;

    // Register information about Task and Mbx Id
    // This step depends on the architecture, e.g. when using the RTL it is not required
    if ((result = PxNameRegister(TASK_C1_CONTROL_NAMESERVERID,sizeof(taskinfo_t),&Task_C1_Control_info)) != PXERR_NOERROR)
    {
	    DET_stop(AUTOCORE,REGISTERNAME, result);
    }


	
/*******************************************************************************************************
 * Initialise the runtime environment
 *******************************************************************************************************/
	SYNC_SetC1(TASKS_CREATED);


/*******************************************************************************************************
 * All cores are ready, tasks can be activated
 *******************************************************************************************************/


    if ((result = PxTaskSignalEvents(Task_C1_Control_Id, ev_Task_C1_Control_0_Activate)) != PXERR_NOERROR)
	{
		DET_stop(AUTOCORE,SIGNALEVENT, result);
	}

/*******************************************************************************************************
 * Start endless background loop with lowest priority
 *******************************************************************************************************/

	SYNC_SetC1(TASKS_READY);
	
	//At this point of time, we have to make sure that the safety critical OS instance on core 0 is up and running
    //Depending on the architecture, this may be ommitted
#if CORE != 0
    SYNC_C12WaitForC0State(TASKS_READY, TIMEOUTSYNC, PXBOOTSYNC2);
#endif

	//Lowest prio
	PxTaskSetPrio(PxGetId(), MINPRIO_CORE1);

/*******************************************************************************************************
 * Timing analysis configuration
 *******************************************************************************************************/

#ifdef RTE_TIMING_ANALYSIS
	// Get the task names for the timing analysis
	RTE_TIME_appTaskInitDetails[CORE][RTE_TIME_noOfAppTasksInCore1].taskID = Task_C1_Control_Id;
	PxTaskGetName(Task_C1_Control_Id, &(RTE_TIME_appTaskInitDetails[CORE][RTE_TIME_noOfAppTasksInCore1++].taskName[0]), 20);
#endif //RTE_TIMING_ANALYSIS

	// Endless loop for background task
	while (1) {
		asm("wait");
	}


}


